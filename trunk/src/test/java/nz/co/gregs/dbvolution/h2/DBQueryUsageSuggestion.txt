package nz.co.gregs.dbvolution.h2;

import java.util.List;

import nz.co.gregs.dbvolution.DBQuery;
import nz.co.gregs.dbvolution.DBQueryRow;
import nz.co.gregs.dbvolution.example.CarCompany;
import nz.co.gregs.dbvolution.example.Marque;

/**
 * Alternative suggestions for usability of a DBQuery and DBQueryRow type.
 * @author Malcolm Lett
 */
public class DBQueryUsageSuggestion {
	// test that the most common usage is easy to do:
	//   JOIN two tables, adding WHERE on any fields within either table, and having
	//   the tree of associations automatically built up.
	// NOTE: internally within dbvolution, this is probably a convenience mapping from List<Map<Class, DBTableRow<?>>

//Essentially this is asking for a heirarchical query from CarCompany which is not relational at all.
//However that doesn't mean it's wrong, you may just be voicing the opinion of all the Java engineers I rail against.
//So this seems like a good idea to implement from a usability perspective.
//The bad news is implementing it is problematic: a well formed schema would cause us to load the whole database,
//OR repeatedly query the database when we are trying to make moderately queries trivial.
//Either solution is problematic.
//There is a compromise solution, but I see problems with that too: we query forward only one level.
//But even that can get very big very fast and we don't even know if they wanted the extra level
//The fourth option is that we only query forward on the tables that are added.
//But that seems confusing to me, not sure why, it just doesn't seem right.
//Also the getMarques() method is a bit magical isn't? I mean CarCo has the PK, 
//so getMarques is an added method generated by a second pass over the schema?
//This one should be put on the shelf for a while, give it time to cool...
	public static void getCarCompanyWithCommonTreeAssociations() {
            // assumes: CarCompany class has property "marques: List<Marque>";
            DBSimpleQuery<CarCompany> dbQuery = new DBSimpleQuery<CarCompany>(myDatabase);
            CarCompany carCompany = new CarCompany();
            carCompany.name.isLiterally("TOYOTA");
            dbQuery.add(carCompany);
            dbQuery.add(new Marque());

            List<CarCompany> results = dbQuery.getAllRows();

            for (CarCompany company: results) {
                    System.out.println(company);
                    for (Marque marque: company.getMarques()) {
                            System.out.println("   "+marque);
                    }
            }
	}

	// minor alternative to the above
//More or less the same as above tho you need new DBSimpleQuery<CarCompany>(myDatabase, carCompany)
//I like the idea of new DBSimpleQuery(myDatabase, DBTable...) as a quick and easy way to make the query :)
	public static void getCarCompanyWithCommonTreeAssociations2() {
        CarCompany carCompany = new CarCompany();
        carCompany.name.isLiterally("TOYOTA");
        DBSimpleQuery<CarCompany> dbQuery = new DBSimpleQuery<CarCompany>(carCompany);
        dbQuery.add(new Marque());
        
        List<CarCompany> results = dbQuery.getAllRows();
        
        // ...etc...
	}

	// test that the weirder joins can be supported
	public static void getArbitraryJoin() {
        DBArbitraryQuery dbQuery = new DBArbitraryQuery(myDatabase);
        CarCompany carCompany = new CarCompany();
        carCompany.name.isLiterally("TOYOTA");
        dbQuery.add(carCompany);
        dbQuery.add(new Marque());
        // ...plus other crazy joiny stuff that doesn't fit in the above examples.
        // ...maybe the ability to specify how tables are joined?? eeek.
//Eeek indeed! This "here a miracle occurs" bit has been annoying me for a while :-S
//could we do something like dbQuery.add(marque, marque.getName, DBOperator.EQUALS, carCompany.getName)
//or is that just too diabolical?
//It is, isn't it :(
//An only hideous option might be dbQuery.add(marque, "marque.name = carCompany.Name")
//but getting the raw SQL right would be, umm, hideous.
//Of course the other problem is Java programmer will just use it all the time, instead of defining the schema properly.
//Sigh...

        List<DBQueryRow> results = dbQuery.getAllRows();
        dbQuery.printAll();

        for (DBQueryRow queryRow : results) {
            CarCompany carCo = (CarCompany) queryRow.get(carCompany);
            String carCoName = carCo.name.toString();

            Marque marque = (Marque) queryRow.get(new Marque());
            Long marqueUID = marque.getUidMarque().longValue();

            System.out.println(carCoName + ": " + marqueUID);
        }
	}
}
